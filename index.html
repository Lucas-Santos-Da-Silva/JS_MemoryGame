<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jogin da Memória</title>
    <link rel="stylesheet" href="style.css">
    <link rel="shortcut icon" href="./assets/orange.png" type="image/x-icon">
    <link rel="manifest" href="manifest.json">
</head>
<body>
    <h1>Jogin da Memória</h1>
    <div class="grid-container"></div>
    <p>Score: <span class="score"></span></p>
    <div class="actions">
        <button onclick="restart()">Restart</button>
    </div>

    <script>if ('serviceWorker' in navigator) {
// Nome do cache (controle de versão)
const cachePWA = 'cache-v1'
// Arquivos a serem armazenados em cache
// Todos os arquivos devem ser adicionados ao vetor(exceto o manifesto)
const urlsToCache = [
  './',
  './index.html',  
  './style.css',
  './script.js',
  './sw.js',
  './manifest.json',
  './data/cards.json',
  './assets/cherries.png',
  './assets/chili.png',
  './assets/grapes.png',
  './assets/lemon.png',
  './assets/orange.png',
  './assets/pineapple.png',
  './assets/strawbery.png',
  './assets/tomato.png',
  './assets/watermelon.png',
]

// Instalando o Service Worker e armazenando os arquivos no cache
self.addEventListener('install', (event) => {
  event.waitUntil(
    caches.open(cachePWA)
      .then((cache) => {
        return cache.addAll(urlsToCache)
      })
  )
})

// Interceptando as solicitações de rede e servindo arquivos do cache quando offline
self.addEventListener('fetch', (event) => {
  event.respondWith(
    caches.match(event.request)
      .then((response) => {
        // Se o arquivo está no cache, serve o arquivo do cache
        if (response) {
          return response
        }
        // Caso contrário, faz uma solicitação de rede
        return fetch(event.request)
      })
  )
})    
}
    </script>

    <script src="script.js"></script>
</body>
</html>